#!/usr/bin/env python3import argparsefrom core.io.audio_loader import load_audio, save_audiofrom core.hybrid.pipeline import process_audiodef main():    parser = argparse.ArgumentParser(        description="Digital Reverse Engine â€” Deterministic Timing Edition"    )    parser.add_argument("input", type=str, help="Input audio file")    parser.add_argument(        "--mode",        type=str,        required=True,        choices=[            "TRUE_REVERSE",            "QBEAT_REVERSE",            "HQ_REVERSE",            "STUDIO_REVERSE",            "TATUM_REVERSE",        ],        help="Reverse mode",    )    parser.add_argument("--output", type=str, required=True, help="Output audio file")    # Deterministic timing parameters    parser.add_argument(        "--tempo",        type=float,        default=120.0,        help="Tempo in BPM (default: 120.0)",    )    parser.add_argument(        "--beats-per-bar",        type=int,        default=4,        help="Beats per bar (default: 4)",    )    # Tatum-specific parameter    parser.add_argument(        "--tatum-fraction",        type=float,        default=0.25,        help="Subdivision for TATUM_REVERSE (default: 0.25 = quarter-beat)",    )    args = parser.parse_args()    # Load audio    audio, sr = load_audio(args.input)    # Dispatch based on mode    if args.mode == "TATUM_REVERSE":        out = process_audio(            audio,            sr,            mode=args.mode,            tempo=args.tempo,            beats_per_bar=args.beats_per_bar,            tatum_fraction=args.tatum_fraction,        )    else:        out = process_audio(            audio,            sr,            mode=args.mode,            tempo=args.tempo,            beats_per_bar=args.beats_per_bar,        )    # Save output    save_audio(args.output, out, sr)if __name__ == "__main__":    main()