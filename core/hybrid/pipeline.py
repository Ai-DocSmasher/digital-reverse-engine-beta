# core/hybrid/pipeline.pyimport timeimport numpy as npfrom core.dsp.reverse_modes import (    true_reverse,    qbeat_reverse,    hq_reverse,    studio_reverse,    tatum_reverse,)from core.economic.cost_estimator import CostEstimatorfrom core.economic.receipt_generator import generate_receipt# -------------------------------------------------------------------# DSP MODE MAP (deterministic timing, no Librosa)# -------------------------------------------------------------------MODE_MAP = {    "TRUE_REVERSE": true_reverse,    "QBEAT_REVERSE": qbeat_reverse,    "HQ_REVERSE": hq_reverse,    "STUDIO_REVERSE": studio_reverse,    "TATUM_REVERSE": tatum_reverse,}# -------------------------------------------------------------------# DSP-ONLY PIPELINE (used by dre.py CLI)# -------------------------------------------------------------------def process_audio(    audio: np.ndarray,    sample_rate: int,    mode: str,    tempo: float = 120.0,    beats_per_bar: int = 4,    tatum_fraction: float = 0.25,    **kwargs,) -> np.ndarray:    """    DSP-only processing entrypoint.    All structural modes use deterministic TimingGrid (no Librosa).    This is what the CLI (dre.py) should call.    """    if mode not in MODE_MAP:        raise ValueError(f"Unknown mode: {mode}")    dsp_fn = MODE_MAP[mode]    if mode == "TATUM_REVERSE":        return dsp_fn(            audio=audio,            sample_rate=sample_rate,            tempo=tempo,            beats_per_bar=beats_per_bar,            tatum_fraction=tatum_fraction,            **kwargs,        )    return dsp_fn(        audio=audio,        sample_rate=sample_rate,        tempo=tempo,        beats_per_bar=beats_per_bar,        **kwargs,    )# -------------------------------------------------------------------# FULL HYBRID PIPELINE (DSP + economic engine)# -------------------------------------------------------------------def process_audio_hybrid(    audio: np.ndarray,    sample_rate: int,    mode: str,    tier: str,    enriched_metadata: dict,    tempo: float = 120.0,    beats_per_bar: int = 4,    tatum_fraction: float = 0.25,    **kwargs,):    """    Full production pipeline:    - Deterministic DSP (TimingGrid-based)    - Cost estimation    - Gating    - Receipt generation    """    if mode not in MODE_MAP:        raise ValueError(f"Unknown mode: {mode}")    dsp_fn = MODE_MAP[mode]    # DSP timing    t0 = time.time()    if mode == "TATUM_REVERSE":        processed = dsp_fn(            audio=audio,            sample_rate=sample_rate,            tempo=tempo,            beats_per_bar=beats_per_bar,            tatum_fraction=tatum_fraction,            **kwargs,        )    else:        processed = dsp_fn(            audio=audio,            sample_rate=sample_rate,            tempo=tempo,            beats_per_bar=beats_per_bar,            **kwargs,        )    dsp_time = time.time() - t0    # Economic engine    estimator = CostEstimator()    cost = estimator.estimate_cost(enriched_metadata)    gating = estimator.apply_gating(cost, tier)    # Receipt    receipt = generate_receipt(        input_audio=audio,        output_audio=processed,        metadata=enriched_metadata,        mode=mode,        tier=tier,        datacostunits=cost,        gating=gating,    )    meta = {        "mode": mode,        "tier": tier,        "sample_rate": sample_rate,        "input_shape": audio.shape,        "output_shape": processed.shape,        "dsp_time_s": dsp_time,        "datacostunits": cost,        "gating": gating,    }    return processed, meta, receipt# -------------------------------------------------------------------# Local test harness# -------------------------------------------------------------------if __name__ == "__main__":    sr = 44100    audio = np.random.randn(sr * 4).astype(np.float32)    enriched_metadata = {        "contribution_type": "internal_test",        "complexity_factor": 1.0,        "transient_density": 0.2,        "quality_proxy_score": 1.0,    }    out, meta, receipt = process_audio_hybrid(        audio,        sample_rate=sr,        mode="HQ_REVERSE",        tier="free",        enriched_metadata=enriched_metadata,        tempo=128.0,        beats_per_bar=4,    )    print(meta)    print(receipt["signature"][:12])