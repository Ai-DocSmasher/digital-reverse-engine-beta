# core/dsp/reverse_modes.pyimport numpy as npfrom core.timing.grid import TimingGriddef _reverse_by_grid(audio: np.ndarray, grid: np.ndarray) -> np.ndarray:    """    Helper: slice audio by grid, reverse order of slices, keep audio inside slices forward.    Works for mono or stereo.    """    segments = []    for start, end in zip(grid[:-1], grid[1:]):        segments.append(audio[start:end])    if not segments:        return audio.astype(np.float32)    segments = segments[::-1]    out = np.concatenate(segments, axis=0)    # Pad/trim to original length    if len(out) > len(audio):        out = out[:len(audio)]    elif len(out) < len(audio):        if audio.ndim == 1:            out = np.pad(out, (0, len(audio) - len(out)))        else:            out = np.pad(out, ((0, len(audio) - len(out)), (0, 0)))    return out.astype(np.float32)def quarterbeat_reverse(    audio: np.ndarray,    sample_rate: int,    tempo: float = 120.0,    beats_per_bar: int = 4,    subdivision: float = 0.25,    **kwargs):    grid = TimingGrid(sample_rate=sample_rate, tempo=tempo, beats_per_bar=beats_per_bar)    g = grid.build_grid(len(audio), unit="subdivision", fraction=subdivision)    return _reverse_by_grid(audio, g)def qbeat_reverse(    audio: np.ndarray,    sample_rate: int,    tempo: float = 120.0,    beats_per_bar: int = 4,    subdivision: float = 0.25,    **kwargs):    """    QBEAT_REVERSE:    Deterministic quarter-beat structural reverse.    No detection, DAW-style timing.    """    grid = TimingGrid(sample_rate=sample_rate, tempo=tempo, beats_per_bar=beats_per_bar)    g = grid.build_grid(len(audio), unit="subdivision", fraction=subdivision)    return _reverse_by_grid(audio, g)def hq_reverse(    audio: np.ndarray,    sample_rate: int,    tempo: float = 120.0,    beats_per_bar: int = 4,    **kwargs):    """    HQ_REVERSE:    Deterministic beat-level structural reverse.    One slice per beat.    """    grid = TimingGrid(sample_rate=sample_rate, tempo=tempo, beats_per_bar=beats_per_bar)    g = grid.build_grid(len(audio), unit="beat")    return _reverse_by_grid(audio, g)def studio_reverse(    audio: np.ndarray,    sample_rate: int,    tempo: float = 120.0,    beats_per_bar: int = 4,    bars_per_slice: int = 1,    **kwargs):    """    STUDIO_REVERSE (guaranteed multi-bar reverse):    - Slices audio into N-bar chunks    - Reverses the ORDER of the chunks    - Ensures at least 2 slices so reversal is audible    """    grid = TimingGrid(sample_rate=sample_rate, tempo=tempo, beats_per_bar=beats_per_bar)    # Compute slice size    slice_samples = grid.bar_samples * bars_per_slice    total = len(audio)    # Build grid    import numpy as np    grid_points = np.arange(0, total, slice_samples, dtype=int)    # Guarantee at least 2 slices    if len(grid_points) < 2:        # Force a midpoint slice        midpoint = total // 2        grid_points = np.array([0, midpoint, total], dtype=int)    else:        # Append final endpoint if missing        if grid_points[-1] != total:            grid_points = np.append(grid_points, total)    # Slice → reverse order → concatenate    segments = [audio[start:end] for start, end in zip(grid_points[:-1], grid_points[1:])]    segments = segments[::-1]    out = np.concatenate(segments, axis=0)    # Pad/trim to match original length    if len(out) > total:        out = out[:total]    elif len(out) < total:        if audio.ndim == 1:            out = np.pad(out, (0, total - len(out)))        else:            out = np.pad(out, ((0, total - len(out)), (0, 0)))    return out.astype(np.float32)def tatum_reverse(    audio: np.ndarray,    sample_rate: int,    tempo: float = 120.0,    beats_per_bar: int = 4,    tatum_fraction: float = 0.25,    **kwargs):    """    TATUM_REVERSE:    Sub-beat structural reverse.    tatum_fraction:        0.25 -> 1/4 beat        0.33 -> ~triplet        0.5  -> 1/2 beat    """    grid = TimingGrid(sample_rate=sample_rate, tempo=tempo, beats_per_bar=beats_per_bar)    g = grid.build_grid(len(audio), unit="subdivision", fraction=tatum_fraction)    return _reverse_by_grid(audio, g)def true_reverse(audio: np.ndarray, sample_rate: int, **kwargs):    """    Classic tape-style reverse: flip waveform.    """    if audio.ndim == 1:        out = audio[::-1]    else:        out = audio[::-1, :]    return out.astype(np.float32)